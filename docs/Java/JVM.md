📝《深入理解Java虚拟机》第三版，读书笔记。
## 一 走进Java
略。
## 二 Java内存区域与内存溢出异常
### 2.1 程序计数器

1. 是一块较小的内存，是当前线程所执行的字节码的行号指示器。
1. **线程私有**。
1. 如果是正在执行一个Java方法，记录的是虚拟机字节码的指令地址。
1. 如果是执行的本地方法，则为空（Undefined）。
1. 唯一一个没有规定任何OOM Error的区域。
### 2.2 Java虚拟机栈

1. **线程私有。**
1. 描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧（Stack Frame）**用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
1. 每一次方法的调用就对应着一个栈帧在虚拟机栈从**入栈**到**出栈**的过程。
1. 异常
   1. 如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverFlowError；
   1. 如果Java虚拟机栈容量可以动态拓展（HotSpot不可以），当栈扩展时无法申请到足够的内存会抛出OOM异常。
### 2.3 本地方法栈

1. 作用与虚拟机栈相似，区别在于是为本地方法服务。
1. 异常与虚拟机栈一样。
### 2.4 Java堆

1. **线程共享**。虚拟机启动时创建。
1. **几乎**所有的对象实例都在这里分配内存。（栈上分配除外）
1. 是垃圾收集器管理的内存区域。
1. 所有线程共享的Java堆中可以划分出多个线程私有的**分配缓冲区**（Thread Local Allocation Buffer），以提升对象分配时的效率。
1. Java堆可以处于**物理上不连续**的内存空间中，但在**逻辑上**它应该被视为**连续**的。
1. Java堆既可以被实现成固定大小的，也可以是可拓展的，主流是可拓展。如果Java堆中没有内存完成实例分配，并且堆也无法拓展时，Java虚拟机将会抛出OOM异常。
### 2.5 方法区

1. **线程共享**
1. 存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
1. 相对而言垃圾收集行为在这个区域比较少见。
1. 这个区域的内存回收目标主要是针对**常量池**的回收和**类型的卸载**。
1. 如果方法区无法满足新的内存分配需求时，将抛出OOM异常。
### 2.6 运行时常量池

1. 是方法区的一部分。
1. 存放编译期生成的各种**字面量**与**符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。
1. 当常量池无法申请到内存时会抛出OOM异常。
### 2.7 直接内存

1. 不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。
## 三 垃圾收集器与内存分配策略
### 3.1 概述

1. **程序计数器、虚拟机栈、本地方法栈**三个区域随线程而生，随线程而灭。这个几个区域的内存分配和回收都具备**确定性**，所以不需要考虑内存回收问题。
1. **Java堆和方法区**这两个区域则有显著的**不确定性**：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们在知道程序究竟创建了哪些对象，创建了多少个对象，这部分内存的分配和回收是动态的。
### 3.2 对象已死？

1. **引用计数算法**
   1. 原理：在对象中添加一个应用计数器，当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器的值为零的对象就是不可能再被使用。
   1. 缺点：很难解决对象之间相互循环引用的问题。
2. **可达性分析算法**
   1. 原理：通过一些列称为“**GC Roots**”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。
   1. **可作为GC Roots的对象类型**
      1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等；
      1. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
      1. 在方法区中常量引用的对象，譬如字符串常量池里的引用。
      1. 在本地方法栈中JNI（Java Native Method）引用的对象。
      1. Java虚拟机内部的引用，如基本数据类型对应的Class对象等。
      1. 所有被同步锁（synchronized 关键字）持有的对象。
      1. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
      1. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整GC Roots集合。
3. 再谈引用
   1. **强引用**：是指在程序代码之中普遍存在的引用赋值。只要强引用关系还存在，垃圾收集器就永远**不会回收**被引用的对象。
   1. **软引用**：用来描述一些还有用，但非必须的对象。在系统将要发生**内存溢出异常前**，会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
   1. **弱引用**：用来描述非必须对象，强度比软引用更弱一些，被弱引用引用的对象只能够活到**下一次垃圾收集**发生为止。
   1. **虚引用**：最弱的一种引用关系。
4. 生存还是死亡？
   1. 即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，要真正宣告一个对象死亡，至少要经历**两次标记****过程**
      1. 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记。筛选出有必要执行finalize()方法的对象，放置在**F-Queue**队列中。
      1. 收集器会对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize中成功拯救自己--只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移出“即将回收”的集合。
5. 回收方法区
   1. 方法区垃圾收集的“性价比”通常是比较低的。
   1. 方法区的垃圾收集主要回收两部分内容：**废弃的常量和不再使用的类型**。
### 3.3 垃圾收集算法

1. **分代收集理论**
   1. 弱分代假说：绝大多数对象都是朝生夕灭的。
   1. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
   1. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。
2. 名词定义
   1. 部分收集（Partial GC）
      1. 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
      1. 老年代收集（Major GC/Old GC）：指目标是老年代的垃圾收集。**只有CMS收集器有单独收集老年代的行为**。
      1. 混合收集（Mixed GC）：指收集整个新生代以及部分老年代的垃圾收集。**只有G1收集器会有这种行为**。
   2. 整堆收集（Full GC）
      1. 收集整个Java堆和方法区的垃圾收集。
3. **标记清除**
   1. 原理：算法分为“标记”和“清除”两个阶段。先标记存活的对象，然后统一回收未被标记的对象。
   1. 缺点：**效率不稳定**，要清除的对象大、多，效率就降低；**产生大量内存碎片**。
4. **标记复制**
   1. 原理：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。
   1. 缺点：可用内存缩小为了原来的**一半**。
   1. **Apple式回收**：将新生代分为一块较大的**Eden**空间和两块较小的**Survivor**空间（**8:1:1**），每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其它内存区域（大多是老年代）进行**分配担保**。
5. **标记整理**
   1. 原理：先标记，然后将所有存活的对象向内存空间的一端移动，然后直接清理掉边界以外的内存。
   1. 缺点：移动存活的对象是一次极为负重的操作，会发生“**Stop The World**”；不移动，又会产生更多的内存碎片引入更复杂的问题。基于以上两点，**移动则内存回收更复杂，不移动则内存分配时更复杂**。**“和稀泥式”**解决方案，平时都用标记-清除算法，带到内存碎片化已经无法容忍时，再执行标记-整理算法以获得规整的内存空间。CMS就是这种方案。
### 3.4 经典垃圾收集器

1. Serial：单线程工作的收集器，在执行垃圾收集时，必须暂停其他工作线程，直到收集结束。
1. ParNew：Serial的多线程并行版本。
1. Parallel Scavenge：新生代收集器，基于标记复制算法实现。目标是达到一个可控制的吞吐量。
1. Serial Old：是Serial收集器的老年代版本，单线程收集，基于标记整理算法。
1. Parallel Old：PS的老年代版本，支持多线程并发收集，基于标记整理算法。
1. **CMS**：是一种以获取最短回收停顿时间为目标的收集器。过程如下：
   1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。
   1. 并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时长但**不阻塞用户线程**。
   1. 重新标记：此步骤是为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录。
   1. 并发清除：清理掉标记阶段的已经死亡的对象，由于不移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
   1. 缺点：无法处理“浮动垃圾”；产生内存碎片。
      1. 在CMS的并发标记和并发清理期间，用户线程还在继续运行，程序还在运行就还会产生新的垃圾对象，但这一部分垃圾对象是出现在标记过程之后，CMS无法在当次GC中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾称为**“浮动垃圾”**。
7. **Garbage First**：开创了面向局部收集的设计思路和基于Region的内存布局形式。
   1. **停顿时间模型**：是指能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集器上的时间大概率不超过N毫秒这样的目标，这几乎是实时Java（RTSJ）中软实时垃圾收集器的特征了。
   1. 它可以面向堆内存任何部分来组成**回收集（Collection Set）**进行回收，衡量标准不再是它属于哪个分代，而是那块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed模式。
   1. 把连续的Java堆划分为多个大小相等的独立区域（**Region**），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。
   1. 虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，他们都是一些列区域（不需要连续）的动态集合。
   1. G1之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的**最小单元**，即每次收集到的内存空间都是Region大小的**整数倍**，这样可以有计划的避免在整个Java堆中进行全区域的垃圾收集。具体实现思路是跟踪每一个Region的垃圾堆积的“价值”大小，价值即回收所获得空间以及回收所需要时间的经验值，然后后台维护一个优先级链表，然后每次根据用户设定的收集停顿时间优先处理回收价值收益大的哪些Region。
   1. **G1运作过程**
      1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要**短暂停顿用户线程**。
      1. 并发标记：从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时长，但可以与用户程序并发执行。
      1. 最终标记：对用户线程做另外一个短暂的暂停，用户处理并发标记阶段结束后仍遗留下来的最后那少量SATB记录。
      1. 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以选择任意多个Region构成回收集，然后决定回收哪一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里涉及到存活对象的移动，必须暂停用户线程，由多条收集器线程并行完成。
8. **G1与CMS的比较**
   1. G1优点
      1. 可以指定最大停顿时间
      1. 分Region的内存布局
      1. 按收益动态确定回收集
      1. G1宏观上看是标记整理，微观上看是标记复制，意味着内存碎片更少
   2. G1缺点
      1. G1需要消耗10%-20%的内存空间来维护卡表
      1. 维护卡表的逻辑上G1的执行负载更高
9. **并发与并行**
   1. 并行：描述的是多条垃圾收集线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。
   1. 并发：描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。
### 3.5 对象的内存分配
对象的内存分配，从概念上讲，应该都是在**堆上分配**，而实际上也有可能经过即时编译后被拆散为标量类型并间接的在**栈上分配**。

1. **对象优先在Eden分配**
   1. 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
   1. 经过Minor GC过后，如果Eden中的对象无法放入Survivor区，则通过**分配担保机制**提前转移到老年代去。
2. **大对象直接进入老年代**
   1. 避免大对象原因
      1. 在分配空间时，明明还有不少内存空间就提前触发垃圾收集，以获取足够连续空间才能安置好它们。
      1. 当复制对象时，高额的内存复制开销。
   2. HotSpot虚拟机提供了 **-XX:PretenureSizeThreshold** 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。
      1. 该参数只对Serial和ParNew两款新生代收集器有效，HotSpot的其他新生代收集器，如Parallel Scavenge并不支持这个参数。如果必须使用此参数进行调优，可考虑ParNew加CMS的收集器组合。
3. **长期存活的对象将进入老年代**
   1. 对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15），就会被晋升到老年代中。
   1. 对象晋升老年代的年龄阈值，可以通过参数 **-XX:MaxTenuringThreshold **设置。
4. **动态对象年龄判定**
   1. 为了更好的适应不同程序的内存情况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX:MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的**一半**，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到-XX:MaxTenuringThreshold中要求的年龄。
5. **空间分配担保**
   1. 在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看 **-XX:HandlePromotionFailure **参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。
## 十 前端编译与优化
### 10.1 概述

1. 前端编译器：把*.java文件转变成*.class文件；
1. 即时编译器：在运行期把字节码转变成本地机器码；
1. 提前编译器：直接把程序编译成与目标机器指令集相关的二进制代码；
### 10.2 Javac编译器

1. 编译过程（1个准备3个处理）
   1. **准备过程**：初始化插入式注解处理器。
   1. **解析与填充符号表**
      1. 词法、语法分析。将源代码的字符流转变成标记集合，构造出抽象语法树。
      1. 填充符号表。产生符号地址和符号信息。
   3. **插入式注解处理器的注解处理过程**。
   3. **分析与字节码生成**
      1. 标注检查。对语法的静态信息进行检查。
      1. 数据流及控制流分析。对程序动态运行过程进行检查。
      1. 解语法糖。将简化代码编写的语法糖还原为原有的形式。
      1. 字节码生成。将前面各个步骤所生成的信息转化成字节码。
## 十一 后端编译与优化
### 11.1 概述

1. 编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。
### 11.2 即时编译器

1. 目前主流JVM里，Java程序最初都是通过解释器进行解释进行**解释执行**的，当虚拟机发现某个方法或者代码块的运行特别频繁，就会把这些代码认定为“热点代码”，为了提高热点代码的执行效率，**在运行时**，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能的进行代码优化，运行时完成这个任务的后端编译器被称为**即时编译器**。
1. 解释器与编译器
   1. **解释执行节约内存；编译执行提升效率。**
   1. HotSpot内置三个即时编译器
      1. 客户端编译器（Client Compiler，C1）
      1. 服务端编译器（Server Compiler，C2）
      1. 长期目标替代C2的Graal编译器
   3. 为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了**分层编译**的功能。
3. 编译对象与触发条件
   1. 编译对象“热点代码”
      1. **被多次调用的方法**
      1. **被多次执行的循环体**
      1. 对于这两种情况，**编译的目标对象都是整个方法体，而不会是单独的循环体**。
      1. “栈上替换”：方法的栈帧还在栈上，方法就被替换了。
   2. 触发条件“热点探测”
      1. **基于采样的热点探测**：周期性地检查各个线程的调用栈顶，经常出现在栈顶的方法就是热点方法。优点简单高效；缺点精确度不高，易受到线程阻塞和外界因素干扰。
      1. **基于计数器的热点探测**：虚拟机会为每个方法（甚至代码块）建立计数器，统计方法的执行次数，如果次数超过一定阈值就认为它是热点方法。优点统计精确度高；缺点需要额外维护计数器。
4. 编译过程
### 11.3 提前编译器
待整理
### 11.4 编译器优化技术

1. 即时编译器对代码的优化是建立在**代码的中间表示或者机器码**之上的，绝不是直接在Java源码上去做的。
1. **方法内联**
   1. 把目标方法的代码原封不动的“复制”到发起调用的方法之中，**避免发生真实的方法调用**。
3. **逃逸分析**
   1. 分析对象的动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种被称为**方法逃逸**；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为**线程逃逸**。从**不逃逸、方法逃逸到线程逃逸**，称为对象由低到高的逃逸程度。
   1. 如果能证明一个对象不会逃逸到方法外或者线程外，或者逃逸程度低，则可以对这个对象实例采取不同程度的优化
      1. **栈上分配**
         1. 如果确定一个对象不会逃逸出**线程**之外，那么这个对象会被栈上分配，对象所占用的内存空间就可以随栈帧出栈而销毁。
         1. **栈上分配可以支持方法逃逸，但不能支持线程逃逸。**
      2. **标量替换**
         1. 如果把一个Java对象**拆散**，根据程序访问的情况，将其用到的成员变量恢复为**原始类型**来访问，这个过程就称为**标量替****换**。
         1. 假如逃逸分析能够证明一个对象不会被**方法**外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的**成员变量**来代替。将对象拆分后，除了可以让对象的成员变量在**栈上分配和读写**外，还可以为后续进一步优化手段创造条件。
         1. 标量替换可以视为栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出**方法**范围内。
      3. **同步消除**
         1. 线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个**变量**不会逃逸出**线程**，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对或者变量实施的**同步措施**也就可以安全的消除掉。
4. **公共子表达式消除**
   1. 如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。
5. **数组边界检查消除**
   1. 如果编译器只要通过**数据流分析**就可以判定循环变量的取值范围永远在区间 [0, arr.length) 之内，那么在循环中就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。
## 十二 Java内存模型与线程
### 12.1 硬件的效率与一致性

1. 基于高速缓存的存储交互很好的解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：**缓存一致性**。当多个处理器的运算任务都涉及同一块主内存区域时，将导致各自的缓存数据不一致。
### 12.2 Java内存模型

1. 《Java虚拟机规范》中曾试图定义一种“Java内存模型”来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序各种平台下都能达到一致的内存访问效果。
1. 主内存与工作内存
   1. Java内存模型规定了所有的**变量**都存储在**主内存**中。
   1. 每条**线程**有自己的**工作内存**，线程的工作内存中保存了被该线程使用的变量的主内存**副本**，线程对变量的所有操作都必须在工作内存中进行，而**不能直接读写主内存中的数据**。
   1. 不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量值的传递均需要通过主内存来完成**。
3. 对于volatile型变量的特殊规则
   1. 对所有线程的“**可见性**”。
   1. **禁止指令重排序优化**。
      1. **内存屏障**：指排序时不能把后面的指令重排序到内存屏障之前的位置。
4. todo
### 12.3 Java与线程

1. 线程的实现
   1. **内核线程**：使用内核线程实现的方式也被称为**1:1**实现。内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核同故宫操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。
   1. **用户线程**：使用用户线程实现的方式被称为**1:N**实现。广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程的一种。狭义上来看，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。
   1. **混合实现**：混合实现下，即存在用户线程，也存在轻量级进程。
   1. **Java线程的实现**：JDK1.3起，主流虚拟机的线程模型普遍都被替换为**基于****操作系统原始线程模型**来实现。
2. Java线程调度
   1. **抢占式调度**（Java采用的）
   1. **协同式调度**
3. 状态转换
   1. **新建**（New）：创建后尚未启动的线程处于这种状态。
   1. **运行**（Runnable）：包括操作系统线程状态中的**Running和Ready**，也就是处于此状态的线程有可能正在执行，也有可能正在等待操作系统为它分配执行时间。
   1. **无限期等待**（Waiting）：处于这种状态的线程不会被分配到处理器执行时间，它们要等待被其他线程显示唤醒。以下方法会让线程进入无限期等待状态：
      1. 没有设置Timeout参数的Object::wait()方法；
      1. 没有设置Timeout参数的Object::join()方法；
      1. LockSupport::park()方法；
   4. **限期等待**（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显示唤醒，在一定时间后他们会由系统自动唤醒。以下方法会让线程进入此状态：
      1. Thread::sleep()方法
      1. 设置了Timeout参数的Object::wait()方法；
      1. 设置了Timeout参数的Thread::join()方法；
   5. **阻塞**（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是前者在等待着获取到一个**排他锁**，这个事件将在另外一个线程放弃这个锁的时候发生；而后者则是等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
   5. **结束**（Terminated）：已终止的线程状态。
### 12.4 Java与协程

1. 由于最初多数的用户线程是被设计成**协同式调度**的，所以也叫**协程**。
1. 又由于这个时候的协程会完整地做调用栈的保护、恢复工作，所以今天也被称为“**有栈协程**”。
1. 无栈协程本质上是一种**有限状态机**，状态保存在闭包内，自然比有栈协程恢复调用栈要轻量得多，但功能也相对有限。
1. 对于有栈协程，有一种特例实现名为**纤程（Fiber）**。
## 十三 线程安全与锁优化
### 13.1 线程安全

1. 当**多个线程同时访问一个对象时**，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行其他的任何协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是**线程安全**的。
1. Java语言中的线程安全
   1. 不可变
   1. 绝对线程安全
   1. 相对线程安全
   1. 线程对立
3. 线程安全是实现方法
   1. **互斥同步**：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。也叫阻塞同步。
   1. **非阻塞同步**：基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程争用共享数据，那操作就是直接成功了；如果共享的数据的确被争用，产生了冲突，再进行补偿机制，常见是不断重试，直到没有竞争的共享数据为止。**CAS**操作，由**Unsafe**类提供硬件级别的原子操作。
   1. **无同步方案**：同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保障其准确性，因此会有一些代码天生就是线程安全的。
      1. 可重入代码
      1. 线程本地存储
### 13.2 锁优化

1. **自旋锁与自适应自旋**
   1. 大多数情况下，共享数据的锁定状态只会维持很短的一个时间，为了这段时间挂起和恢复一个线程不值得。故而让线程暂不放弃处理器的执行时间，而是执行一个**忙循环（自旋）**。自旋时间过长消耗资源，故默认自旋**10**次。
   1. JDK 6引入自适应自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的。
2. **锁消除**
   1. 指虚拟机**即时编译器**在**运行时**，对一些代码要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于“**逃逸分析**”的数据支持。
3. **锁粗化**
3. **轻量级锁**
   1. 轻量级锁并不是用来代替重量级锁的，它的设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
   1. 如果出现两个以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁。
   1. 轻量级锁能提升程序同步性能的依据是“**对于绝大部分的锁，在整个同步周期内都是不存在竞争的**”这一经验法则。如果没有竞争，轻量级锁便通过CAS成功避免了使用互斥量的开销；但如果的确存在锁竞争，除了互斥量本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。
5. **偏向锁**
   1. 目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。
   1. “偏”是指这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中，该锁一直没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。
   1. 一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束了。
   1. 偏向锁可以提高带有同步但无竞争的程序性能，但它同样是带有一个效益权衡性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。





