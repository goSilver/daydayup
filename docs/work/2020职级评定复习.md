## 一、Java SE
1. **抽象类和接口有什么区别？**
- **抽象类**
    - 抽象类可以定义构造器
    - 可以有抽象方法和具体方法
    - 抽象类可以定义成员变量
    - 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
    - 抽象类中可以包含静态方法
    - 一个类只能继承一个抽象类
- **接口**
    - 接口中不能定义构造器
    - 全部方法都是抽象方法
    - 接口中不能有静态方法
    - 一个类可以实现多个接口
- **相同点**
    - 不能够实例化
    - 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法进行全部实现，否则该类仍然需要被声明为抽象类

2. **集合框架**

Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。

- **set**：接口存储一组唯一，无序的对象。

- **list**：接口存储一组不唯一，有序（插入顺序）的对象。
    - LinkedList：底层是链表结构，查找效率低，增删效率高。线程不安全。
    - ArrayList：底层是数组结构，查找效率高，增删效率低。线程不安全。
    - vector：和ArrayList相似。线程安全。
    
- **map**
    - HashMap：线程不安全。数组和链表组合构成。键值都允许为null。Java8之前头插，之后尾插。使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。https://mp.weixin.qq.com/s/0Gf2DzuzgEx0i3mHVvhKNQ
    - HashTable：线程安全。效率低。键值都不允许为null。
    - ConrrentHashMap：线程安全，分段锁技术。1.8抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。ABA问题，版本号、时间戳。

- **queue、stack**：队列先进先出；栈先进后出。

3. **多线程**
- **多线程的创建方式**
    - 继承Thread类；
    - 实现Runnable接口；
    - 使用 ExecutorService、Callable、Future 实现有返回结果的多线程；

- **wait()和sleep()的区别**：最大的不同是在等待时 wait 会释放锁，而 sleep一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。

- **synchronized和volatile关键字的作用**
    - volatile：一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后就具备两层语义。1、保证了不同线程对这个变量进行操作时的可见性。2、禁止指令重排序。
    - volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的
    - volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性
    - volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
    - volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化

- **什么是线程池**：线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节
省了开辟子线程的时间，提高的代码执行效率。

- **常见的线程池有哪些**
    - newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
    - newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
    - newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。
    - newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。
    - newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。

- **线程池的好处**
    - 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
    - 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
    - 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

- **线程池启动策略**
    - 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。
    - 当调用 execute() 方法添加一个任务时，线程池会做如下判断：
        - 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
        - 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。
        - 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务；
        - 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。
    - 当一个线程完成任务时，它会从队列中取下一个任务来执行。
    - 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。

4. **注解、常用类、JDK新特性**
5. **JDBC**
6. **数据结构和算法**
7. **JSON、XML解析**
8. **JVM**
    - JVM内存模型
        - 程序计数器：是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。
        - 虚拟机栈：线程私有。每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。
        - 本地方法栈：
        - 堆：堆存放的对象是线程共享的，所以多线程的时候也需要同步机制。GC算法管理的区域，所以又分新生代、老年代。
        - 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。
    - GC算法优缺点
        - 引用计数法：缺点，每次对象赋值时均要维护GC计数器，且计数器本身会有一定消耗；难处理循环引用。 
        - 复制算法：原理，将堆内存一分为二，GC时将存活的对象copy到A区，清除B区。缺点，浪费内存。
        - 标记清除：原理，从根节点开始扫描，标记存活的对象；再从根节点，清楚未标记对象。缺点，两次扫描，耗时严重；产生内存碎片。
        - 标记整理：原理，从根节点扫描，标记存活的对象，整理，将存活的对象集中往一端移动。缺点，标记、整理过程效率低。优点，不浪费内存，不产生内存碎片。
        - 实际：针对不同的区采用不同的收集算法。新生代对象存活率低，适合复制算法；老年代区域较大，适合标记整理、标记清除。

### 二、框架
1. **Spring**
- bean的生命周期
    - bean 定义：在配置文件里面用<bean></bean>来进行定义。
    - bean 初始化：有两种方式初始化:
        - 在配置文件中通过指定 init-method 属性来完成
        - 实现 org.springframwork.beans.factory.InitializingBean 接口
    - bean 调用：有三种方式可以得到 bean 实例，并进行调用
    - bean 销毁：销毁有两种方式
        - 使用配置文件指定的 destroy-method 属性
        - 实现 org.springframwork.bean.factory.DisposeableBean 接口

- Spring如何管理事务
    - 编程式：在代码中显式挪用 beginTransaction()、commit()、rollback()等事务治理相关的方法，这就是编程式事务管理。Spring 对事物的编程式管理有基于底层 API 的编程式管理和基于 TransactionTemplate 的编程式事务管理两种方式。
    - 声明式：用在 Spring 配置文件中或注解声明式的处理事务来代替代码式的处理事务。事务管理不侵入业务代码。

- Spring Boot
    - 约定优于配置
    - 减少配置文件
    - 简单、快速、方便的搭建项目
    - 对主流框架无配置集成

- Spring MVC
    - 它通过⼀套注解，让⼀个简单的 Java 类成为处理请求的控制器，⽽⽆须实现任何接⼝。同时它还⽀持RESTful 编程⻛格的请求。
    - 本质可以认为是对servlet的封装，简化了我们serlvet的开发

- MVC
    - Model（模型）：模型包含业务模型和数据模型，数据模型⽤于封装数据，业务模型⽤于处理业务。
    - View（视图）： 通常指的就是我们的 jsp 或者 html。作⽤⼀般就是展示数据的。通常视图是依据模型数据创建的。
    - Controller（控制器）： 是应⽤程序中处理⽤户交互的部分。作⽤⼀般就是处理程序逻辑的。
    - MVC提倡：每⼀层只编写⾃⼰的东⻄，不编写任何其他的代码；分层是为了解耦，解耦是为了维护⽅便和分⼯协作。

- 如何理解ORM的
    - ORM全称：Object/Relation Mapping 对象-关系映射
    - 在日常开发过程中，我们都是使用面向对象的思维实现业务逻辑，但是在设计数据库表或者操作数据库记录，则需要通过关系型思维方式思考问题。应用程序与关系型数据库之间进行交互时，数据在对象和关系结构中的表、列、字段等之间进行转换。

- JDBC存在的问题
    - **数据库链接频繁创建、销毁**造成系统资源浪费；
    - **重复性代码**很多，不利于维护；
    - SQL语句存在**硬编码**，不利于维护，实际开发中SQL变化的可能较大，SQL变化会导致Java代码变化；
    - 使用Statement想占位符中设置参数值存在**硬编码**，实际开发中where条件变化会导致Java代码变化；
    - 对结果集解析存在**硬编码**（查询列名），SQL变化导致解析代码变化，不利于维护。

- 设计模式
    - 使用过策略模式
    - 熟悉单例、代理模式

- MQ
    - 解决了什么问题 
        - 同步变异步
        - 流量削峰
        - 解耦降低服务间的耦合性
    - 消息重复消费：根据单号幂等；或者由请求方提供唯一标识做幂等；
    - 消息丢失
        - 生产者：try-catch，发送消息失败就报异常，合理重试机制
        - Broker：需要控制响应的时机，单机情况下是消息刷盘后返回响应，集群多副本情况下，即发送至两个副本及以上的情况下再返回响应
        - 消费者：需要在执行完真正的业务逻辑之后再返回响应给Broker

- MySQL锁
    - 共享锁，英文名：Shared Locks，简称S锁。在事务要读取一条记录时，需要先获取该记录的S锁。
    - 独占锁，也常称排他锁，英文名：Exclusive Locks，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁。
    - 分粒度锁：表级别；行级别

- 分布式锁











