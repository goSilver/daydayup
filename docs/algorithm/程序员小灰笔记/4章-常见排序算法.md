## 1 引言
根据时间复杂度的不同，主流的排序算法可以分为3大类。

1. 时间复杂度为_**O(n^2)**_的排序算法
   1. 冒泡排序
   1. 选择排序
   1. 插入排序
   1. 希尔排序（性能略优于O(n^2)，但又比不上O(nlogn)，故放在这）
2. 时间复杂度为_**O(nlogn)**_的排序算法
   1. 快速排序
   1. 归并排序
   1. 堆排序
3. 时间复杂度为_**O(n)**_的排序算法
   1. 计数排序
   1. 桶排序
   1. 基数排序

此外，排序算法还可以根据其稳定性，划分为**稳定排序**和**不稳定排序**。

1. 稳定排序：值相同的元素在排序后，仍然保持着排序前的相对位置。
1. 不稳定排序：值相同的元素在排序后，排序前的相对位置被打乱。
## 2 冒泡排序
冒泡排序的英文名是**bubble sort**，它是一种基础的**交换排序**。
### 2.1 思想
把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。


冒泡排序是一种**稳定排序**，值相等的元素并不会打乱原本的顺序。由于该排序算法的每一轮都要遍历所有的元素，总共遍历n-1轮，所以平均时间复杂度是**O(n^2)**。
### 2.2 代码实现
```java
    /**
     * 暴力版冒泡
     * 外层循环控制所有的回合
     * 内层循环实现每一轮的冒泡处理
     * 先进行元素比较，再进行元素交换
     * <p>
     * 时间复杂度：O(n^2)
     *
     * @param arr 数组
     */
    private void sort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            // 注意，这里边界可以是length-1，优化一下也可以是length-i-1
            for (int j = 0; j < arr.length - i - 1; j++) {
                // 注意
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                }
            }
        }
    }
```
### 2.3 冒泡的优化：

1. 利用布尔变量**isSorted**作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，则说明数列已然有序，然后直接跳出大循环。
1. 利用无序数列的边界**sortBorder**。在每一轮排序过程中，处于sortBorder之后的元素就不需要再进行比较了，肯定是有序的。
1. 鸡尾酒排序：原始冒泡是进行单向位置交换，鸡尾酒排序的元素比较和交换过程是**双向**的，排序过程就像钟摆一样。



代码实现：gitHub
## 3 快速排序
同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。
### 3.1 思想
快速排序在每一轮挑选一个**基准元素**，并让其他比它大的元素移动到数列的一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分，这种思路叫**分治法**。在分治法的思想下，原数列在每一轮都被拆分为两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。


每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是O(n)，平均情况下要遍历logn轮，因此快速排序算法总体的平均时间复杂度是**O(nlogn)**。但是，如果是一个原本就**逆序**的数列，快速排序需要进行n轮，时间复杂度退化成**O(n^2)**。
### 3.2 代码实现
github
## 4 堆排序
### 4.1 思想 
堆排序算法步骤

1. 把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。
1. 循环删除堆顶元素，替换到二叉堆的末尾，调整产生新的堆顶。
### 4.2 和快排比较

1. 平均时间复杂度都是O(nlogn)，并且都是不稳定
1. 快排最坏情况下O(n^2)，而堆排序稳定在O(nlgn)
1. 快排递归、非递归的空间复杂度都是O(logn)，而堆排序的空间复杂度是O(1)
### 4.3 代码实现
github



| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定排序 |
| :---: | :---: | :---: | :---: | :---: |
| 冒泡排序 | O(n^2) | O(n^2) | O(1) | 稳定 |
| 鸡尾酒排序 | O(n^2) | O(n^2) | O(1) | 稳定 |
| 快速排序 | O(nlogn) | O(n^2) | O(logn) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 计数排序 | O(n+m) | O(n+m) | O(m) | 稳定 |
| 桶排序 | O(n) | O(nlogn) | O(n) | 稳定 |







