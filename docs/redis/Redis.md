# Redis

## 1、Redis基础
1. **基本数据结构**
   1. 基础：String、Hash、List、Set、SortedSet
   1. 高级：HyperLogLog、Geo、Pub/Sub



2. **Redis实现分布式锁**

   1. 介绍一下Redis怎么实现分布式锁？
      1. 先拿**setnx**来争抢锁，抢到之后，再用**expire**给锁加一个过期时间防止锁忘记了释放。

   2. 如果setnx之后，执行expire之前进程意外crash或者要重启，会发生什么？
      1. 这个锁就永远得不到释放了。解决：set指令有非常复杂的参数，这个应该是可以同时把**setnx**和**expire**合成一条指令来用。


3. **Redis实现异步队列**
   1. **实现方式**：一般使用list结构作为队列，**rpush**生产消息，**lpop**消费消息。当lpop没有消息的时候，要适当sleep一会再重试。或者使用blpop指令，list还有个指令叫**blpop**，在没有消息的时候，它会阻塞住直到消息到来。
   1. **如何配置多消费者**：使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如**RocketMQ**等。
   1. **如何实现延时队列**：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用**zrangebyscore**指令获取N秒之前的数据轮询进行处理。




4. **Redis的持久化**
   1. **RDB**：镜像全量持久化
      1. 优点：由**fork**的子进程来持久化，对Redis本身性能影响小；恢复数据速度快。
      1. 缺点：数据完整性没有AOF高，会丢失最近几分钟的数据。
   2. **AOF**：增量持久化
      1. 优点：数据完整性更高。
      1. 缺点：AOF文件要比RDB文件大；**fsync**操作会影响Redis性能。




5. **内存淘汰机制**
   1. **过期策略**
      1. **定期删除**：默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。
      1. **惰性删除**：不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。
   2. **内存淘汰机制**
      1. **noeviction**：返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
      1. **allkeys-lru**：尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
      1. **volatile-lru**：尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
      1. **allkeys-random**：回收随机的键使得新添加的数据有空间存放。
      1. **volatile-random**：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
      1. **volatile-ttl**：回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。
## 2、缓存雪崩、穿透、击穿

1. **缓存雪崩**
   1. **什么情况发生**：同一时间，大量的key**同时失效**，缓存就跟没有一样，大量的请求直接打到DB上。
   1. **如何解决**：
      1. 在**批量**往Redis存数据的时候，把每个Key的失效时间都加个随机值。
      1. 如果**Redis**是集群部署，将热点数据均匀分布在不同的**Redis**库中。
      1. 或者设置热点数据永远不过期，有更新操作就更新缓存就好了。



2. **缓存穿透**
   1. **什么情况发生**：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，例如查询id为-1的数据。
   1. **如何解决**：接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。




3. **缓存击穿**
   1. **什么情况发生：**跟**缓存雪崩**有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。
   1. **如何解决**：正常用户的请求量不会击穿缓存，一般是恶意攻击导致，可在网关层配置一个‘单个IP的每秒访问次数阈值’。


## 3、Redis高可用

1. **主从**

主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器**切换**为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。

![](https://cdn.nlark.com/yuque/0/2021/webp/2548312/1614606481384-2e247b94-ce27-4d79-bc6e-976fc50e63ea.webp#align=left&display=inline&height=490&margin=%5Bobject%20Object%5D&name=&originHeight=490&originWidth=1080&size=0&status=done&style=none&width=1080)

数据同步原理：
启动一台slave 的时候，他会发送一个**psync**命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成**RDB**快照，还会把新的写请求都缓存在内存中，**RDB**文件生成后，master会将这个**RDB**发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。

2. **哨兵模式**

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是**哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。**

![](https://upload-images.jianshu.io/upload_images/11320039-57a77ca2757d0924.png?imageMogr2/auto-orient/strip|imageView2/2/w/507/format/webp)

这里的哨兵有两个作用

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。

- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机。


然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。


用文字描述一下**故障切换（failover）**的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为**客观下线**。这样对于客户端而言，一切都是透明的。
